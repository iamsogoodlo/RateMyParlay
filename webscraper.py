from bs4 import BeautifulSoup
import pandas as pd
import requests

# Define bet types
bet_types = ["over/under", "moneyline", "player props"]

def player_name(first_name, last_name):
    """
    Generates a player ID based on the first and last name of a player.
    
    Args:
        first_name (str): The first name of the player.
        last_name (str): The last name of the player.
    
    Returns:
        str: A unique player ID combining the first and last name.
    """
    first_name = first_name.replace(" ", "").lower()
    last_name = last_name.replace(" ", "").lower()
    return last_name[:5] + first_name[:2]

def team_name(name):
    """
    Converts a team name to its corresponding abbreviation.

    Args:
        name (str): The full team name (e.g., 'Golden State Warriors').
    
    Returns:
        str: The team's abbreviation (e.g., 'GSW').
    """
    team_abbreviations = {
        "Golden State Warriors": "GSW",
        "Los Angeles Lakers": "LAL",
        "Chicago Bulls": "CHI",
        "Miami Heat": "MIA",
        "Boston Celtics": "BOS",
        "Toronto Raptors": "TOR",
        "New York Knicks": "NYK",
        "Houston Rockets": "HOU",
        "Philadelphia 76ers": "PHI",
        "Dallas Mavericks": "DAL",
        "San Antonio Spurs": "SAS",
        "Phoenix Suns": "PHX",
        "Milwaukee Bucks": "MIL",
        "Denver Nuggets": "DEN",
        "Utah Jazz": "UTA",
        "Cleveland Cavaliers": "CLE",
        "Atlanta Hawks": "ATL",
        "Brooklyn Nets": "BKN",
        "Portland Trail Blazers": "POR",
        "Washington Wizards": "WAS",
        "Minnesota Timberwolves": "MIN",
        "Orlando Magic": "ORL",
        "Charlotte Hornets": "CHA",
        "Sacramento Kings": "SAC",
        "New Orleans Pelicans": "NOP",
        "Oklahoma City Thunder": "OKC",
        "Detroit Pistons": "DET",
        "Indiana Pacers": "IND",
        "Memphis Grizzlies": "MEM",
    }
    return team_abbreviations.get(name, "Unknown Team")

def create_url_player(name):
    """
    Creates a URL to access a player's stats on Basketball Reference.

    Args:
        name (str): The player ID generated by `player_name()`.
    
    Returns:
        str: The URL to the player's stats page.
    """
    initial = name[0]
    return f"https://www.basketball-reference.com/players/{initial}/{name}01.html"

def create_url_team(team_name):
    """
    Creates a URL to access a team's game stats for the 2025 season on Basketball Reference.

    Args:
        team_name (str): The team abbreviation (e.g., 'GSW').
    
    Returns:
        str: The URL to the team's game stats page.
    """
    return f"https://www.basketball-reference.com/teams/{team_name}/2025_games.html"

def scrape_team_stats(url):
    """
    Scrapes and parses the team game statistics from the provided URL.

    Args:
        url (str): The URL to the team's game stats page.
    
    Returns:
        pd.DataFrame: A DataFrame containing the last 5 team game statistics.
    
    Raises:
        ValueError: If the table with ID 'games' is not found.
    """
    response = requests.get(url)
    response.raise_for_status()

    soup = BeautifulSoup(response.text, 'html.parser')
    table = soup.find('table', id='games')
    if not table:
        raise ValueError("Table with ID 'games' not found!")

    data = []
    rows = table.find_all('tr')
    for row in rows[1:]:
        cols = row.find_all('td')
        cols_text = [col.text.strip() for col in cols]
        if cols_text:
            data.append(cols_text)

    df = pd.DataFrame(data, columns=["G", "", "Date", "Start", "", "Opp", "W/L", "OT", "TP", "OP", "W", "L", "Streak", "Attend.", "LOG", "Notes"])
    return df.tail(5)

def scrape_player_stats(url):
    """
    Scrapes and parses the player's statistics from the provided URL.

    Args:
        url (str): The URL to the player's stats page.
    
    Returns:
        pd.DataFrame: A DataFrame containing the last 5 player game statistics.
    
    Raises:
        ValueError: If the table with ID 'last5' is not found.
    """
    response = requests.get(url)
    response.raise_for_status()

    soup = BeautifulSoup(response.text, 'html.parser')
    table = soup.find('table', id='last5')
    if not table:
        raise ValueError("Table with ID 'last5' not found!")

    data = []
    rows = table.find_all('tr')
    for row in rows[1:]:
        cols = row.find_all('td')
        cols_text = [col.text.strip() for col in cols]
        if cols_text:
            data.append(cols_text)

    df = pd.DataFrame(data, columns=["Date", "Team", "Opp", "Result", "GS", "MP", "FG", "FGA", "FG%", "3P", "3PA", "3P%", "FT",
                                      "FTA", "FT%", "ORB", "DRB", "TRB", "AST", "STL", "BLK", "TOV", "PF", "PTS", "GmSc", "+/-"])
    return df

def calculate_expected_value(odds, amount_wagered):
    """
    Calculates the expected value of a bet, given the odds and amount wagered.

    Args:
        odds (int): The betting odds (e.g., +200, -150).
        amount_wagered (float): The amount of money wagered.

    Returns:
        dict: A dictionary with the implied probability, profit on win, profit on loss, and expected value.
    
    Raises:
        ValueError: If odds are not an integer or amount wagered is not a valid float.
    """
    try:
        odds = int(odds)
        amount_wagered = float(amount_wagered)

        if odds > 0:
            # Positive odds
            implied_probability = 100 / (odds + 100)
            profit_on_win = amount_wagered * (odds / 100)
        else:
            # Negative odds
            implied_probability = abs(odds) / (abs(odds) + 100)
            profit_on_win = amount_wagered * (100 / abs(odds))

        # Loss is always the amount wagered
        profit_on_loss = -amount_wagered

        # Calculate expected value
        expected_value = (implied_probability * profit_on_win) + ((1 - implied_probability) * profit_on_loss)

        return {
            "implied_probability": round(implied_probability, 4),
            "profit_on_win": round(profit_on_win, 2),
            "profit_on_loss": round(profit_on_loss, 2),
            "expected_value": round(expected_value, 2)
        }
    except ValueError:
        return "Invalid input! Please ensure odds are an integer and the amount wagered is a number."

def take_leg(bet_type, df):
    """
    Handles the logic for placing a bet based on the player's statistics.

    Args:
        bet_type (str): The type of bet ('over/under', 'moneyline', etc.).
        df (pd.DataFrame): A DataFrame containing player statistics.
    
    Returns:
        int: The number of times the condition (over/under) is met.
    
    Raises:
        ValueError: If the bet type is invalid or the stat is not found in the dataframe.
    """
    while True:
        try:
            if bet_type == "over/under":
                over_under = input("Was your stat an over or under? (over/under): ").lower()
                if over_under == "over":
                    comparison_operator = ">"
                elif over_under == "under":
                    comparison_operator = "<"
                else:
                    raise ValueError("Invalid input. Please type 'over' or 'under'.")

                stat = input("What stat was your bet? ").strip()
                if stat not in df.columns:
                    raise ValueError(f"Stat '{stat}' not found in the player stats dataframe.")

                stat_number = float(input("What is the bet over/under number? "))

                times_true = 0
                for _, row in df.iterrows():
                    player_stat = float(row[stat])
                    if comparison_operator == ">" and player_stat > stat_number:
                        times_true += 1
                    elif comparison_operator == "<" and player_stat < stat_number:
                        times_true += 1

                print(f"The condition was met {times_true} times.")
                return times_true

            else:
                raise ValueError("Bet type not recognized or not supported.")
        except ValueError as e:
            print(e)

def rate_leg(times_true):
    """
    Rates the leg of the bet based on how many times the condition was met.

    Args:
        times_true (int): The number of times the bet condition was met.
    
    Returns:
        str: The rating of the leg ('Good' or 'Bad').
    """
    if times_true >= 3:
        return "Good"
    return "Bad"

# Main script
while True:
    try:
        first_name = input("Player first name: ")
        last_name = input("Player last name: ")
        name = player_name(first_name, last_name)
        url = create_url_player(name)
        df = scrape_player_stats(url)
        break
    except Exception as e:
        print(f"Error fetching player stats: {e}. Please try again.")

while True:
    try:
        bet_type = input("What is your bet type: ").lower()
        times_true = take_leg(bet_type, df)
        if times_true is not None:
            leg_rating = rate_leg(times_true)
            print(f"Leg rating: {leg_rating}")
            break
    except Exception as e:
        print(f"Error evaluating leg: {e}. Please try again.")

while True:
    try:
        odds = input("Odds of bet (+/-): ")
        amt_wagered = input("How much did you wager: ")
        ev = calculate_expected_value(odds, amt_wagered)
        if ev:
            print("Expected Value Calculation:", ev)
            break
    except Exception as e:
        print(f"Error calculating expected value: {e}. Please try again.")
